----------------------------------------------------------------------------
-- Mastrovito Multiplier (mastrovito_multiplier.vhd)
--
-- Computes the polynomial multiplication mod f in GF(2**m)
-- The hardware is genenerate for a specific f.
--
-- 
----------------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
package mastrovito_multiplier_parameters is
  constant M: integer := 8;
  constant F: std_logic_vector(M-1 downto 0):= "00011011";
  --constant F: std_logic_vector(M-1 downto 0):= x"001B"; --for M=16 bits
  --constant F: std_logic_vector(M-1 downto 0):= x"0101001B"; --for M=32 bits
  --constant F: std_logic_vector(M-1 downto 0):= x"010100000101001B"; --for M=64 bits
  --constant F: std_logic_vector(M-1 downto 0):= x"0000000000000000010100000101001B"; --for M=128 bits
  --constant F: std_logic_vector(M-1 downto 0):= "000"&x"00000000000000000000000000000000000000C9"; --for M=163
  --constant F: std_logic_vector(M-1 downto 0):= (0=> '1', 74 => '1', others => '0'); --for M=233
  type matrix_reductionP is array (0 to M-2) of STD_LOGIC_VECTOR(M-1 downto 0);
  function reduction_matrix_P return matrix_reductionP;
  type matrix_mastrovito is array (0 to M-1) of STD_LOGIC_VECTOR(M-1 downto 0);
--  constant P: matrix_reduction := reduction_matrix_P;
end mastrovito_multiplier_parameters;

package body mastrovito_multiplier_parameters is
  function reduction_matrix_P return matrix_reductionP is
  variable P: matrix_reductionP;
  begin
  for J in 0 to M-1 loop
      P(0)(J) := F(J);
  end loop;
  for I in 1 to M-2 loop
      P(I)(0) := P(I-1)(M-1);
      for J in 1 to M-1 loop
         P(I)(J) := P(I-1)(J-1) xor (P(I-1)(M-1) and (P(0)(J)) ); 
      end loop;
   end loop;
   return P;
end reduction_matrix_P;

end mastrovito_multiplier_parameters;


------------------------------------------------------------
-- Classic Multiplication
------------------------------------------------------------
library ieee; 
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
use work.mastrovito_multiplier_parameters.all;

entity mastrovito_multiplication is
port (
  a, b: in std_logic_vector(M-1 downto 0);
  c: out std_logic_vector(M-1 downto 0)
);
end mastrovito_multiplication;

architecture simple of mastrovito_multiplication is
  constant P: matrix_reductionP := reduction_matrix_P;
  signal Z: matrix_mastrovito;
begin
  -- Gen Z matrix
  z_matrix: process(a,z)
    variable Zi: matrix_mastrovito;
  begin
  for i in 0 to M-1 loop
    zi(i)(0) := a(i);
    zi(i)(1) := (P(0)(i) and a(M-1));
    if i >= 1 then   
      zi(i)(1) := (a(i-1) xor zi(i)(1));
    end if;
    for j in 2 to M-1 loop
      zi(i)(j) := (P(j-1)(i) and a(M-1));
      for t in 1 to j-1 loop
        zi(i)(j) := (zi(i)(j) xor (P(j-1-t)(i) and a(M-1-t)));
      end loop;
      if i >= j then   
        zi(i)(j) := (a(i-j) xor zi(i)(j));
      end if;
    end loop;
  end loop;
  Z <= zi;
  end process;

 --Mastrovito multiplication
  mastrovito: process(b,z)
    variable ci: std_logic_vector(M-1 downto 0);
  begin
  for i in 0 to m-1 loop
    ci(i) := (Z(i)(0) and b(0));
    for j in 1 to m-1 loop
      ci(i) := (ci(i) xor (Z(i)(j) and b(j)));
    end loop;
  end loop;
  c <= ci;
  end process;  
  
end simple;

----An alternative (and equivalent) architecture based on "generate" 
--architecture advGenerate of mastrovito_multiplication is
--  constant P: matrix_reductionP := reduction_matrix_P;
--  signal Z: matrix_mastrovito;
--
--begin
--  -- Gen Z matrix
--  genZ1: for i in 0 to M-1 generate
--    z(i)(0) <= a(i);
--    genZ2: for j in 1 to M-1 generate
--      proc1: process(a)
--        variable tempz: std_logic;
--      begin
--      tempz := '0';
--      for t in 1 to j-1 loop
--        --tempz := (tempz xor (P(j-1-t)(i) and a(M-1-t)));
--        if a(M-1-t) = '1' then
--          tempz := tempz xor P(j-1-t)(i);
--        end if;
--      end loop;
--      if i >= j then
--        tempz := (tempz xor a(i-j));
--      end if;
--      z(i)(j) <= tempz;
--      end process;
--    end generate;
--  end generate;
--  
-- --Mastrovito multiplication
--  genC: for i in 0 to m-1 generate
--      proc2: process(Z,b)
--        variable tempc: std_logic;
--      begin
--        tempc := (Z(i)(0) and b(0));
--        for j in 1 to m-1 loop
--          tempc := (tempc xor (Z(i)(j) and b(j)));
--        end loop;
--        c(i) <= tempc;
--      end process;
--  end generate;
--end advGenerate;
